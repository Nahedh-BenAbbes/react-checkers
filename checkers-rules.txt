General Rules

- 8x8 checkered board
- 2 players
- 12 pieces per player
   - each piece places on dark squares on first two rows
- Pieces can only move diagonally
   - if there is an opponent's piece on one side and empty space after, you can jump and take their piece
      - if you have a jump, you have no choice but to take it
      - you can jump multiple pieces if they line up
- If a piece makes it to the opponent's last row, it is kinged
   - king pieces can move forward and backward but must wait until next turn to exit king row
- Player wins when opponent has no more pieces or can't move
   - for now, just leaving it at no more pieces to make logic easier


HTML
- Checker board
   - 64 divs of alternating styles (black/white)
      - each with an id of their row/column for tracking
- Pieces
   - each will most likely be image || use css to style another div into a circle
   - each will have an id that tracks individual piece
   - each will have click handler that selects the piece


JS
- Player class
   - use redux for state management
   - state
      - numPieces - number of pieces left
      - winner - defaults to false, set true when one wins
   - functions 
      - removePiece()
	     - returns this.numPieces - 1
      - setWinner()
	     - if (otherPlayer.numPieces = 0)
		     return winner = true


	
- Piece class
   - using redux to manage each instance
   - state
      - active - default to true
      - isKing - default to false
	  - color - set based on what side of the board it is on
      - row - row the piece is currently on
      - column - column the piece is currently on
   - functions
      - remove() - removes the piece from the board when overtaken
	     - 
      - king() - sets up a piece as a king if they make it
         - also update the piece with some sort of indicator that it is king
	  - setAllowedMove()
	     - take this.row, this.column, and this.color 
		 - separate if conditions based on color 
		    - nested if condition to see if a piece is already on a spot in front of them
			   - depending on the type of piece, if opposite color, see if another piece is in the spot beyond that for jumping
		 - return array of available spaces to move 
	  - move(rowColumn)
	     - take in rowColumn
		    - render the piece in the new div 
            - remove piece from old div 
               - not sure how to do this yet

- Board class 
   - manage state with redux 
      - state would be an array of objects
	  initialState = { 
	     board: [{ id: 1, row: 1, col: 1, hasPiece: true }],
		 pieces: [{ id: 1, player: 1, currentRow: 1, currentColumn: 1 }]
		}
	  - this might negate the need for a Row component
	  - possibly create 
   - functions 
      - render()
         - something along the lines of:
		 <Row id=1 />
		 <Row id=2 />
		 <Row id=3 />
		 ...etc

- Row class 
   - don't think I'll need redux to manage the state  
   - use css file to style each square in the row 

   - functions 
      - render()
         - render a row with 8 columns
		    - create variable to track this.rowNum + column 
			   - if (this.rowNum == 1 || this.rowNum === 2 || this.rowNum === 7 || this.rowNum === 8)
			      - if (this.rowNum % 2 === 0)
				     - create row div with instantiated Piece class on correct columns
				  - else 
				     - create row div with instantiated Piece class on correct columns 
               - else
			      - if (this.rowNum % 2 === 0)
				     - create row div
				  - else 
				     - create row div
                  - give className from css for the other starting color 			   
		          - give each column div an id = {this.id + colIndex} 


Notes for later
-------------------

CSS / Syling
- Look at :hover in CSS
   - also transition property, i.e.
      transition: background-color 0.4s;
	  
React
- key value for props, React uses to uniquely identify individual instances of classes
   - this will be good when trying to clean up rendering rows 
- payload in dispatch
   - this is how you can pass parameters in dispatch functions 
   
- Removing a piece 
   - use active key as boolean
      - if true, return div with Piece
	  - if false, return div without Piece
   - when Board renders the new state, things that need to change:
      - state.pieces.currentColumn and currentRow where id = Piece.state.id
	  - each col div will need click handler that returns a new state and sets the state.pieces.currentColumn and currentRow to that div's row/column
	  - then Board should re-render with the Piece in the new place
   - when removing a Piece:
      - set the Piece at state.pieces.id to active: false 
	  - have a conditional statement in rendering the Piece class that only renders the span if active is true

- Getting available moves
   - if (this.state.color === red && this.state.isKing === false)
      - access dom for getElementById= `${this.state.currentRow + 1}${this.state.currentColumn +/- 1}`
      - add style to divs to highlight availability and add click handler
   - possibly follow this logic through remainder of scenarios (color black, king, and if another piece is in the way)
      - if a piece is all the way to left or right, make sure you have a condition for such a case
   - find a way to clear the previous styles so only the current piece's available moves get highlighted

Piece placement
[1,2],[1,4],[1,6],[1,8]
[2,1],[2,3],[2,5],[2,7]
[3,2],[3,4],[3,6],[3,8]
- Use if/else if statements
   - instantiate the pieces array in initialState to where they all first start 

- pieces array, what each object will look like 
pieces = [
	{id: 1, currentRow: 1, currentColumn: 2, color: white}
]

Example code snippets of possible board state:



	if (action.type === 'MAKE_KING') {
		const { x, y } = action.payload;
		const pieceIndex = state.pieces.findIndex(
			(piece) => x === piece.position.x && y === piece.position.y
		);
		const newPiecesArray = state.pieces.map((piece, i) => {
			if (i === pieceIndex) {
				piece = { ...piece, isKing: true, letter: 'T' };
			}
			return piece;
		});
		return {
			...state,
			pieces: newPiecesArray,
		};
	}
	
	{this.props.board.map((row, x) => {
					return (
						<div key={x} style={{ display: 'flex' }}>
							{row.map((col, y) => {
								const column = this.props.pieces.find(
									(piece) => x === piece.position.x && y === piece.position.y
								);
								return (
									<button
										key={y}
										style={{ width: '50px', height: '50px' }}
										onClick={() => this.handleClick(x, y)}>
										{column.letter}
									</button>
								);
							})}
						</div>
					);
				})}
				
1st loop
x = 0; y = 1; i = 0;
{ id: 1, currentRow: 0, currentColumn: 1, color: 'black' }
